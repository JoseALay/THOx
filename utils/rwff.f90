! ... Read formfactors and states namelists generated by THOx code
! ... and print them again with imposed restrictions
! ... .............................................................
	  module pairs
	  real*8, allocatable :: exch(:),jpch(:)
	  integer, allocatable:: parch(:)
	  end module pairs


      program readfq
      use pairs
      implicit none     
      logical wbc
      real*8 :: jpi,jpf,x,y
      integer, parameter :: kin=6,kfr=4,kfrout=10
      integer :: nff,nst,i,j,nex,lamax
      integer lam,m1,m2,npt,ir
      real*8 :: ex1,ex2,jp1,jp2,ebind,exmax
      real*8 factor,jt,ptr,ttr,rstep,rfirst,fscale
      complex*16,allocatable :: ffr(:), ffi(:)
      real*8 :: big,small
      character*40 :: filestat,ffin,ffout,comment
      
      namelist /global/    ebind , filestat,ffin,ffout
      namelist /restrict/ lamax,exmax,wbc
      
! ... Initialize some variables
      big=huge(big)
      small=epsilon(small)
      lamax=1000
      wbc=.true. 
       
      read(*,nml=global) 
      read(*,nml=restrict) 
      
      
! ... Read states from states.fr
	  call read_states(nex,filestat)
	  
	  
! ... Read formfactors
      write(*,*)
      write(*,*)' READING/WRITING FORMFACTORS: '
      nff=0 
      open(kfr,   file=ffin, status='old')
      open(kfrout,file=ffout,status='unknown')
10    read(kfr,500,end=600) npt,rstep,rfirst,fscale,lam,ptr,ttr,m2,m1,comment
! Original
500   format(i4,3f8.4,i4,2f4.0,2i4,a35)
! Modified by AMM to allow for more radial points
!500   format(i5,3f8.4,i4,2f4.0,2i4,a35)
	  nff=nff+1
	  jp1=jpch(m1)
      jp2=jpch(m2) 
      ex1=exch(m1)
      ex2=exch(m2)
      
      if (nff.eq.1) allocate(ffr(npt),ffi(npt))
      do ir=1,npt
         read(kfr,*) x,y
         if (abs(x).lt.small) x=small
         if (abs(y).lt.small) y=small
         ffr(ir)= x
         ffi(ir)= y
      enddo !ir 
	  
	  if (lam.gt.lamax) goto 10
	  if ((ex1.gt.exmax).or.(ex2.gt.exmax)) goto 10
	  
	  write(kfrout,500) npt,rstep,rfirst,fscale,lam,ptr,ttr,m2,m1,comment
	  do ir=1,npt
	  x=ffr(ir)
	  y=ffi(ir)
	  if (.not.wbc) then
	    if ((ex1.lt.ebind).and.(ex2.gt.ebind)) y=0
	    if ((ex1.gt.ebind).and.(ex2.lt.ebind)) y=0
	  endif
	  write(kfrout,'(2x,1g16.10,2x,1g16.10)') x,y
	  enddo ! iff
	  
	  goto 10
      
	  
600   write(*,'(/,2x," ->", i4, " formfactors")') nff
    
      end program
      



! ... Read STATES specifications (fresco style) 
      subroutine read_states(nex,filename)
      use pairs
      implicit none
      
      integer, parameter:: kst=20
      integer ie,nex
      integer bandp,bandt,copyp,copyt,cpot,ptyp,ptyt
      real*8 jp,jt,ep,et
      character*40 :: filename
      CHARACTER PARITY(3)
      DATA PARITY / '-','?','+' /     
      
      namelist /states/ jp,bandp,cpot,jt,copyt,bandt,ep,et,ptyp,ptyt
     
      write(*,*)
      write(*,*)' READING STATES: '
      
      open(kst,file=filename,status='old') 
      read(kst,*) nex
      write(*,'(3x,"-> Reading",i4," states from file states.fr")') nex

      if(allocated(exch)) then
        write(*,*)'read_states: trying to reallocate exch!'
        stop
      endif
      allocate(exch(nex))
      allocate(parch(nex))
      allocate(jpch(nex))

      do ie=1,nex
      ep=0; et=0; ptyp=0; ptyt=0;copyt=0; copyp=0;
      read(kst,nml=states)
      exch(ie)  =ep
      parch(ie) =ptyp
      jpch(ie)  =jp
      write(*,'(5x,i3,3x,1f6.3,3x,1f5.1,a1)') ie,ep,jpch(ie),parity(ptyp+2)
      enddo !ie
      end subroutine


